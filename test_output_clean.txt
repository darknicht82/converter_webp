time="2025-11-23T16:36:14-05:00" level=warning msg="C:\\MAMP\\htdocs\\webp\\docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion"
 * @return PDO
 */
function getIntegrationPdo(): PDO
{
    static $pdo = null;

    if ($pdo instanceof PDO) {
        return $pdo;
    }

    $driver = defined('DB_DRIVER') ? DB_DRIVER : 'sqlite';

    try {
        if ($driver === 'pgsql') {
            $dsn = sprintf(
                'pgsql:host=%s;port=%s;dbname=%s;user=%s;password=%s',
                DB_HOST,
                DB_PORT,
                DB_NAME,
                DB_USER,
                DB_PASS
            );
            $pdo = new PDO($dsn);
            $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        } else {
            // Fallback to SQLite
            $databasePath = defined('INTEGRATION_DB_PATH') ? INTEGRATION_DB_PATH : __DIR__ . '/../database/webp_integration.sqlite';
            $directory = dirname($databasePath);
            if (!is_dir($directory)) {
                @mkdir($directory, 0755, true);
            }
            
            $isNew = !file_exists($databasePath);
            $pdo = new PDO('sqlite:' . $databasePath);
            $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
            $pdo->exec('PRAGMA foreign_keys = ON;');
            
            if ($isNew) {
                logIntegrationEvent('INFO', 'Base de datos SQLite creada', ['path' => $databasePath]);
            }
        }
    } catch (PDOException $e) {
        logIntegrationEvent('ERROR', 'Database connection failed', [
            'driver' => $driver,
            'error' => $e->getMessage()
        ]);
        throw new RuntimeException('Database connection failed: ' . $e->getMessage());
    }

    return $pdo;
}

/**
 * Helper to get current timestamp SQL function based on driver.
 */
function getSqlTimestampFunction(): string
{
    return (defined('DB_DRIVER') && DB_DRIVER === 'pgsql') ? 'NOW()' : "datetime('now')";
}

/**
 * Helper to get auto-increment definition.
 */
function getSqlAutoIncrement(): string
{
    return (defined('DB_DRIVER') && DB_DRIVER === 'pgsql') ? 'SERIAL PRIMARY KEY' : 'INTEGER PRIMARY KEY AUTOINCREMENT';
}

/**
 * Inicializa el esquema de base de datos.
 */
function initializeIntegrationDatabase(): void
{
    static $initialized = false;
    if ($initialized) return;

    $pdo = getIntegrationPdo();
    $driver = defined('DB_DRIVER') ? DB_DRIVER : 'sqlite';
    $pk = getSqlAutoIncrement();
    $now = getSqlTimestampFunction();
    $timestampType = $driver === 'pgsql' ? 'TIMESTAMP' : 'TEXT';

    try {
        $pdo->beginTransaction();

        // 1. Clients
        $pdo->exec("CREATE TABLE IF NOT EXISTS integration_clients (
            id $pk,
            client_name TEXT NOT NULL,
            contact_email TEXT,
            api_token TEXT NOT NULL UNIQUE,
            status TEXT NOT NULL DEFAULT 'active',
            monthly_quota INTEGER DEFAULT NULL,
            cost_per_image REAL DEFAULT 0,
            notes TEXT,
            created_at $timestampType NOT NULL DEFAULT $now,
            updated_at $timestampType NOT NULL DEFAULT $now,
            last_used_at $timestampType
        )");

        // 2. Metrics
        $pdo->exec("CREATE TABLE IF NOT EXISTS conversion_metrics (
            id $pk,
            client_id INTEGER NOT NULL,
            period_key TEXT NOT NULL,
            images_processed INTEGER NOT NULL DEFAULT 0,
            total_source_bytes BIGINT NOT NULL DEFAULT 0,
            total_converted_bytes BIGINT NOT NULL DEFAULT 0,
            total_cost REAL NOT NULL DEFAULT 0,
            created_at $timestampType NOT NULL DEFAULT $now,
            updated_at $timestampType NOT NULL DEFAULT $now,
            UNIQUE(client_id, period_key),
            FOREIGN KEY(client_id) REFERENCES integration_clients(id) ON DELETE CASCADE
        )");

        // 3. Events
        $pdo->exec("CREATE TABLE IF NOT EXISTS conversion_events (
            id $pk,
            client_id INTEGER,
            api_token TEXT,
            source_filename TEXT,
            webp_filename TEXT,
            webp_url TEXT,
            source_bytes BIGINT DEFAULT 0,
            converted_bytes BIGINT DEFAULT 0,
            cost REAL DEFAULT 0,
            created_at $timestampType NOT NULL DEFAULT $now,
            FOREIGN KEY(client_id) REFERENCES integration_clients(id) ON DELETE SET NULL
        )");

        // 4. Users
        $pdo->exec("CREATE TABLE IF NOT EXISTS integration_users (
            id $pk,
            email TEXT NOT NULL UNIQUE,
            password_hash TEXT,
            full_name TEXT,
            status TEXT NOT NULL DEFAULT 'active',
            role TEXT NOT NULL DEFAULT 'manager',
            avatar_url TEXT,
            phone TEXT,
            created_at $timestampType NOT NULL DEFAULT $now,
            updated_at $timestampType NOT NULL DEFAULT $now,
            last_login_at $timestampType
        )");

        // 5. User Providers
        $pdo->exec("CREATE TABLE IF NOT EXISTS integration_user_providers (
            id $pk,
            user_id INTEGER NOT NULL,
            provider TEXT NOT NULL,
            provider_user_id TEXT NOT NULL,
            email TEXT,
            access_token TEXT,
            refresh_token TEXT,
            token_expires_at $timestampType,
            created_at $timestampType NOT NULL DEFAULT $now,
            UNIQUE(provider, provider_user_id),
            FOREIGN KEY(user_id) REFERENCES integration_users(id) ON DELETE CASCADE
        )");

        // 6. Sessions
        $pdo->exec("CREATE TABLE IF NOT EXISTS integration_sessions (
            id $pk,
            user_id INTEGER NOT NULL,
            session_token TEXT NOT NULL UNIQUE,
            refresh_token TEXT NOT NULL UNIQUE,
            expires_at $timestampType NOT NULL,
            refresh_expires_at $timestampType NOT NULL,
            ip_address TEXT,
            user_agent TEXT,
            created_at $timestampType NOT NULL DEFAULT $now,
            revoked_at $timestampType,
            FOREIGN KEY(user_id) REFERENCES integration_users(id) ON DELETE CASCADE
        )");

        // 7. User Clients
        $pdo->exec("CREATE TABLE IF NOT EXISTS integration_user_clients (
            id $pk,
            user_id INTEGER NOT NULL,
            client_id INTEGER NOT NULL,
            role TEXT NOT NULL DEFAULT 'owner',
            created_at $timestampType NOT NULL DEFAULT $now,
            revoked_at $timestampType,
            UNIQUE(user_id, client_id),
            FOREIGN KEY(user_id) REFERENCES integration_users(id) ON DELETE CASCADE,
            FOREIGN KEY(client_id) REFERENCES integration_clients(id) ON DELETE CASCADE
        )");

        // 8. API Tokens
        $pdo->exec("CREATE TABLE IF NOT EXISTS integration_api_tokens (
            id $pk,
            user_id INTEGER NOT NULL,
            client_id INTEGER NOT NULL,
            token_hash TEXT NOT NULL UNIQUE,
            label TEXT,
            scopes TEXT,
            expires_at $timestampType,
            last_used_at $timestampType,
            created_at $timestampType NOT NULL DEFAULT $now,
            revoked_at $timestampType,
            UNIQUE(user_id, client_id, label),
            FOREIGN KEY(user_id) REFERENCES integration_users(id) ON DELETE CASCADE,
            FOREIGN KEY(client_id) REFERENCES integration_clients(id) ON DELETE CASCADE
        )");

        // 9. Conversion Logs
        $pdo->exec("CREATE TABLE IF NOT EXISTS conversion_logs (
            id $pk,
            client_id INTEGER NOT NULL,
            filename TEXT NOT NULL,
            original_size BIGINT NOT NULL,
            webp_size BIGINT NOT NULL,
            savings_bytes BIGINT NOT NULL,
            savings_percent REAL NOT NULL,
            cost REAL NOT NULL DEFAULT 0.00,
            status TEXT NOT NULL DEFAULT 'success',
            created_at $timestampType NOT NULL DEFAULT $now,
            FOREIGN KEY(client_id) REFERENCES integration_clients(id) ON DELETE CASCADE
        )");

        // Indices
        $pdo->exec("CREATE INDEX IF NOT EXISTS idx_clients_status ON integration_clients(status)");
        $pdo->exec("CREATE INDEX IF NOT EXISTS idx_metrics_period ON conversion_metrics(period_key)");
        $pdo->exec("CREATE INDEX IF NOT EXISTS idx_events_created_at ON conversion_events(created_at)");
        $pdo->exec("CREATE INDEX IF NOT EXISTS idx_users_status ON integration_users(status)");
        $pdo->exec("CREATE INDEX IF NOT EXISTS idx_sessions_user ON integration_sessions(user_id)");
        $pdo->exec("CREATE INDEX IF NOT EXISTS idx_user_clients_user ON integration_user_clients(user_id)");
        $pdo->exec("CREATE INDEX IF NOT EXISTS idx_api_tokens_user ON integration_api_tokens(user_id)");

        $pdo->commit();
        $initialized = true;
        logIntegrationEvent('INFO', 'Database schema initialized', ['driver' => $driver]);

    } catch (PDOException $e) {
        $pdo->rollBack();
        logIntegrationEvent('ERROR', 'Schema initialization failed', ['error' => $e->getMessage()]);
        throw new RuntimeException('Schema initialization failed: ' . $e->getMessage());
    }
}

/**
 * Configura triggers para updated_at.
 */
function ensureIntegrationTriggers(): void
{
    $pdo = getIntegrationPdo();
    $driver = defined('DB_DRIVER') ? DB_DRIVER : 'sqlite';

    try {
        if ($driver === 'pgsql') {
            // PostgreSQL: Function + Trigger
            $pdo->exec("
                CREATE OR REPLACE FUNCTION update_updated_at_column()
                RETURNS TRIGGER AS $$
                BEGIN
                    NEW.updated_at = NOW();
                    RETURN NEW;
                END;
                $$ language 'plpgsql';
            ");

            $tables = ['integration_clients', 'conversion_metrics', 'integration_users'];
            foreach ($tables as $table) {
                // Check if trigger exists to avoid error
                $exists = $pdo->query("SELECT 1 FROM pg_trigger WHERE tgname = 'trg_{$table}_updated_at'")->fetchColumn();
                if (!$exists) {
                    $pdo->exec("
                        CREATE TRIGGER trg_{$table}_updated_at
                        BEFORE UPDATE ON {$table}
                        FOR EACH ROW
                        EXECUTE FUNCTION update_updated_at_column();
                    ");
                }
            }
        } else {
            // SQLite: Inline Trigger
            $tables = ['integration_clients', 'conversion_metrics', 'integration_users'];
            foreach ($tables as $table) {
                $pdo->exec("
                    CREATE TRIGGER IF NOT EXISTS trg_{$table}_updated_at
                    AFTER UPDATE ON {$table}
                    BEGIN
                        UPDATE {$table}
                        SET updated_at = datetime('now')
                        WHERE id = NEW.id;
                    END;
                ");
            }
        }
    } catch (PDOException $e) {
        logIntegrationEvent('ERROR', 'Trigger setup failed', ['error' => $e->getMessage()]);
        // Don't throw, triggers might already exist or be non-critical
    }
}

// --- Helper Functions (Driver Agnostic) ---

function findIntegrationClientByToken(string $token): ?array
{
    $pdo = getIntegrationPdo();
    $stmt = $pdo->prepare('SELECT * FROM integration_clients WHERE api_token = :token LIMIT 1');
    $stmt->execute([':token' => $token]);
    return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
}

function touchIntegrationClientUsage(int $clientId): void
{
    $pdo = getIntegrationPdo();
    $now = getSqlTimestampFunction();
    $stmt = $pdo->prepare("UPDATE integration_clients SET last_used_at = $now WHERE id = :id");
    $stmt->execute([':id' => $clientId]);
}

function recordIntegrationConversion(array $client, array $payload): bool
{
    $pdo = getIntegrationPdo();
    $driver = defined('DB_DRIVER') ? DB_DRIVER : 'sqlite';
    $now = getSqlTimestampFunction();

    $clientId = (int)($client['id'] ?? 0);
    if ($clientId <= 0) return false;

    $apiToken = $payload['api_token'] ?? ($client['api_token'] ?? null);
    $sourceFilename = $payload['source_filename'] ?? null;
    $webpFilename = $payload['webp_filename'] ?? null;
    $sourceBytes = max(0, (int)($payload['source_bytes'] ?? 0));
    $convertedBytes = max(0, (int)($payload['converted_bytes'] ?? 0));
    $costOverride = isset($payload['cost']) ? (float)$payload['cost'] : null;
    $periodKey = $payload['period_key'] ?? date('Y-m');
    $costPerImage = (float)($client['cost_per_image'] ?? 0);
    $cost = $costOverride !== null ? max(0, $costOverride) : max(0, $costPerImage);

    try {
        $pdo->beginTransaction();

        $webpUrl = $payload['webp_url'] ?? null;
        $insertEvent = $pdo->prepare("INSERT INTO conversion_events (client_id, api_token, source_filename, webp_filename, webp_url, source_bytes, converted_bytes, cost, created_at) VALUES (:client_id, :api_token, :source_filename, :webp_filename, :webp_url, :source_bytes, :converted_bytes, :cost, $now)");
        $insertEvent->execute([
            ':client_id' => $clientId,
            ':api_token' => $apiToken,
            ':source_filename' => $sourceFilename,
            ':webp_filename' => $webpFilename,
            ':webp_url' => $webpUrl,
            ':source_bytes' => $sourceBytes,
            ':converted_bytes' => $convertedBytes,
            ':cost' => $cost
        ]);

        // Upsert Metrics
        if ($driver === 'pgsql') {
            $upsertMetrics = $pdo->prepare(
                "INSERT INTO conversion_metrics (client_id, period_key, images_processed, total_source_bytes, total_converted_bytes, total_cost, created_at, updated_at) 
                VALUES (:client_id, :period_key, :images_processed, :total_source_bytes, :total_converted_bytes, :total_cost, $now, $now)
                ON CONFLICT(client_id, period_key) DO UPDATE SET
                    images_processed = conversion_metrics.images_processed + excluded.images_processed,
                    total_source_bytes = conversion_metrics.total_source_bytes + excluded.total_source_bytes,
                    total_converted_bytes = conversion_metrics.total_converted_bytes + excluded.total_converted_bytes,
                    total_cost = conversion_metrics.total_cost + excluded.total_cost,
                    updated_at = $now"
            );
        } else {
            $upsertMetrics = $pdo->prepare(
                "INSERT INTO conversion_metrics (client_id, period_key, images_processed, total_source_bytes, total_converted_bytes, total_cost, created_at, updated_at) 
                VALUES (:client_id, :period_key, :images_processed, :total_source_bytes, :total_converted_bytes, :total_cost, $now, $now)
                ON CONFLICT(client_id, period_key) DO UPDATE SET
                    images_processed = images_processed + excluded.images_processed,
                    total_source_bytes = total_source_bytes + excluded.total_source_bytes,
                    total_converted_bytes = total_converted_bytes + excluded.total_converted_bytes,
                    total_cost = total_cost + excluded.total_cost,
                    updated_at = $now"
            );
        }

        $upsertMetrics->execute([
            ':client_id' => $clientId,
            ':period_key' => $periodKey,
            ':images_processed' => 1,
            ':total_source_bytes' => $sourceBytes,
            ':total_converted_bytes' => $convertedBytes,
            ':total_cost' => $cost
        ]);

        logConversion($clientId, $sourceFilename ?? 'unknown', $sourceBytes, $convertedBytes, $cost, 'success');
        touchIntegrationClientUsage($clientId);

        $pdo->commit();
        return true;
    } catch (PDOException $e) {
        $pdo->rollBack();
        logIntegrationEvent('ERROR', 'Conversion record failed', ['error' => $e->getMessage()]);
        return false;
    }
}

function generateIntegrationToken(int $length = 48): string
{
    $length = max(16, $length);
    $bytes = random_bytes((int)ceil($length / 2));
    return substr(bin2hex($bytes), 0, $length);
}

function hashIntegrationPassword(string $password): string
{
    return password_hash($password, defined('PASSWORD_ARGON2ID') ? PASSWORD_ARGON2ID : PASSWORD_DEFAULT);
}

function verifyIntegrationPassword(string $password, string $hash): bool
{
    return password_verify($password, $hash);
}

function findIntegrationUserByEmail(string $email): ?array
{
    $pdo = getIntegrationPdo();
    $stmt = $pdo->prepare('SELECT * FROM integration_users WHERE LOWER(email) = LOWER(:email) LIMIT 1');
    $stmt->execute([':email' => $email]);
    return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
}

function findIntegrationUserById(int $id): ?array
{
    $pdo = getIntegrationPdo();
    $stmt = $pdo->prepare('SELECT * FROM integration_users WHERE id = :id LIMIT 1');
    $stmt->execute([':id' => $id]);
    return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
}

function createIntegrationUser(array $data): array
{
    $pdo = getIntegrationPdo();
    $now = getSqlTimestampFunction();
    
    $stmt = $pdo->prepare("INSERT INTO integration_users (email, password_hash, full_name, status, role, avatar_url, phone, created_at, updated_at) VALUES (:email, :password_hash, :full_name, :status, :role, :avatar_url, :phone, $now, $now)");

    $stmt->execute([
        ':email' => strtolower(trim($data['email'])),
        ':password_hash' => isset($data['password']) ? hashIntegrationPassword($data['password']) : null,
        ':full_name' => $data['full_name'] ?? null,
        ':status' => $data['status'] ?? 'active',
        ':role' => $data['role'] ?? 'manager',
        ':avatar_url' => $data['avatar_url'] ?? null,
        ':phone' => $data['phone'] ?? null
    ]);

    $id = (int)$pdo->lastInsertId();
    return findIntegrationUserById($id);
}

function assignIntegrationUserToClient(int $userId, int $clientId, string $role = 'owner'): void
{
    $pdo = getIntegrationPdo();
    $now = getSqlTimestampFunction();
    $stmt = $pdo->prepare("INSERT INTO integration_user_clients (user_id, client_id, role, created_at) VALUES (:user_id, :client_id, :role, $now) ON CONFLICT(user_id, client_id) DO NOTHING");
    $stmt->execute([':user_id' => $userId, ':client_id' => $clientId, ':role' => $role]);
}

function updateIntegrationUserLogin(int $userId): void
{
    $pdo = getIntegrationPdo();
    $now = getSqlTimestampFunction();
    $stmt = $pdo->prepare("UPDATE integration_users SET last_login_at = $now, updated_at = $now WHERE id = :id");
    $stmt->execute([':id' => $userId]);
}

function linkIntegrationUserProvider(int $userId, string $provider, string $providerUserId, array $tokens = []): void
{
    $pdo = getIntegrationPdo();
    $now = getSqlTimestampFunction();
    $driver = defined('DB_DRIVER') ? DB_DRIVER : 'sqlite';

    $sql = "INSERT INTO integration_user_providers (user_id, provider, provider_user_id, email, access_token, refresh_token, token_expires_at, created_at)
        VALUES (:user_id, :provider, :provider_user_id, :email, :access_token, :refresh_token, :token_expires_at, $now)
        ON CONFLICT(provider, provider_user_id) DO UPDATE SET
            user_id = excluded.user_id,
            email = excluded.email,
            access_token = excluded.access_token,
            refresh_token = excluded.refresh_token,
            token_expires_at = excluded.token_expires_at";

    $stmt = $pdo->prepare($sql);
    $stmt->execute([
        ':user_id' => $userId,
        ':provider' => strtolower($provider),
        ':provider_user_id' => $providerUserId,
        ':email' => $tokens['email'] ?? null,
        ':access_token' => $tokens['access_token'] ?? null,
        ':refresh_token' => $tokens['refresh_token'] ?? null,
        ':token_expires_at' => $tokens['token_expires_at'] ?? null
    ]);
}

function findIntegrationUserByProvider(string $provider, string $providerUserId): ?array
{
    $pdo = getIntegrationPdo();
    $stmt = $pdo->prepare('SELECT u.* FROM integration_user_providers p INNER JOIN integration_users u ON u.id = p.user_id WHERE p.provider = :provider AND p.provider_user_id = :provider_user_id LIMIT 1');
    $stmt->execute([':provider' => strtolower($provider), ':provider_user_id' => $providerUserId]);
    return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
}

function getIntegrationClientById(int $id): ?array
{
    $pdo = getIntegrationPdo();
    $stmt = $pdo->prepare('SELECT * FROM integration_clients WHERE id = :id LIMIT 1');
    $stmt->execute([':id' => $id]);
    $client = $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
    if ($client) {
        $client['monthly_quota'] = $client['monthly_quota'] !== null ? (int)$client['monthly_quota'] : null;
        $client['cost_per_image'] = (float)($client['cost_per_image'] ?? 0);
    }
    return $client;
}

function createIntegrationSession(int $userId, string $sessionToken, string $refreshToken, string $expiresAt, string $refreshExpiresAt, ?string $ip = null, ?string $userAgent = null): void
{
    $pdo = getIntegrationPdo();
    $now = getSqlTimestampFunction();
    $stmt = $pdo->prepare("INSERT INTO integration_sessions (user_id, session_token, refresh_token, expires_at, refresh_expires_at, ip_address, user_agent, created_at) VALUES (:user_id, :session_token, :refresh_token, :expires_at, :refresh_expires_at, :ip_address, :user_agent, $now)");
    $stmt->execute([
        ':user_id' => $userId,
        ':session_token' => hash('sha256', $sessionToken),
        ':refresh_token' => hash('sha256', $refreshToken),
        ':expires_at' => $expiresAt,
        ':refresh_expires_at' => $refreshExpiresAt,
        ':ip_address' => $ip,
        ':user_agent' => $userAgent
    ]);
}

function findIntegrationSessionByToken(string $token, bool $isRefresh = false): ?array
{
    $pdo = getIntegrationPdo();
    $column = $isRefresh ? 'refresh_token' : 'session_token';
    $stmt = $pdo->prepare("SELECT * FROM integration_sessions WHERE {$column} = :token AND revoked_at IS NULL LIMIT 1");
    $stmt->execute([':token' => hash('sha256', $token)]);
    return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
}

function revokeIntegrationSession(string $token, bool $isRefresh = false): void
{
    $pdo = getIntegrationPdo();
    $now = getSqlTimestampFunction();
    $column = $isRefresh ? 'refresh_token' : 'session_token';
    $stmt = $pdo->prepare("UPDATE integration_sessions SET revoked_at = $now WHERE {$column} = :token");
    $stmt->execute([':token' => hash('sha256', $token)]);
}

function cleanupExpiredSessions(): void
{
    $pdo = getIntegrationPdo();
    $now = getSqlTimestampFunction();
    $pdo->prepare("DELETE FROM integration_sessions WHERE (expires_at <= $now AND refresh_expires_at <= $now) OR revoked_at IS NOT NULL")->execute();
}

function createIntegrationApiToken(int $userId, int $clientId, string $label, array $scopes = [], ?string $expiresAt = null): array
{
    $pdo = getIntegrationPdo();
    $now = getSqlTimestampFunction();
    $plainToken = generateIntegrationToken(48);
    $hash = hash('sha256', $plainToken);

    $stmt = $pdo->prepare("INSERT INTO integration_api_tokens (user_id, client_id, token_hash, label, scopes, expires_at, created_at) VALUES (:user_id, :client_id, :token_hash, :label, :scopes, :expires_at, $now)");
    $stmt->execute([
        ':user_id' => $userId,
        ':client_id' => $clientId,
        ':token_hash' => $hash,
        ':label' => $label,
        ':scopes' => json_encode($scopes),
        ':expires_at' => $expiresAt
    ]);

    return ['token' => $plainToken, 'label' => $label, 'expires_at' => $expiresAt];
}

function findIntegrationApiToken(string $token): ?array
{
    $pdo = getIntegrationPdo();
    $hash = hash('sha256', $token);
    $stmt = $pdo->prepare('SELECT * FROM integration_api_tokens WHERE token_hash = :hash AND revoked_at IS NULL LIMIT 1');
    $stmt->execute([':hash' => $hash]);
    return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
}

function revokeIntegrationApiToken(int $id): void
{
    $pdo = getIntegrationPdo();
    $now = getSqlTimestampFunction();
    $stmt = $pdo->prepare("UPDATE integration_api_tokens SET revoked_at = $now WHERE id = :id");
    $stmt->execute([':id' => $id]);
}

function getIntegrationClientsForUser(int $userId): array
{
    $pdo = getIntegrationPdo();
    $stmt = $pdo->prepare('SELECT c.*, uc.role AS user_role, uc.created_at AS assigned_at FROM integration_user_clients uc INNER JOIN integration_clients c ON c.id = uc.client_id WHERE uc.user_id = :user_id AND uc.revoked_at IS NULL ORDER BY c.created_at DESC');
    $stmt->execute([':user_id' => $userId]);
    return $stmt->fetchAll(PDO::FETCH_ASSOC);
}

function createIntegrationClient(array $data): ?array
{
    $pdo = getIntegrationPdo();
    $now = getSqlTimestampFunction();
    $token = $data['api_token'] ?? generateIntegrationToken();
    $status = in_array($data['status'] ?? 'active', ['active', 'paused', 'revoked']) ? ($data['status'] ?? 'active') : 'active';

    $stmt = $pdo->prepare("INSERT INTO integration_clients (client_name, contact_email, api_token, status, monthly_quota, cost_per_image, notes, created_at, updated_at) VALUES (:client_name, :contact_email, :api_token, :status, :monthly_quota, :cost_per_image, :notes, $now, $now)");
    $stmt->execute([
        ':client_name' => $data['client_name'],
        ':contact_email' => $data['contact_email'] ?? null,
        ':api_token' => $token,
        ':status' => $status,
        ':monthly_quota' => $data['monthly_quota'],
        ':cost_per_image' => $data['cost_per_image'],
        ':notes' => $data['notes'] ?? null
    ]);

    $id = (int)$pdo->lastInsertId();
    return getIntegrationClientById($id);
}

function updateIntegrationClient(int $id, array $data): bool
{
    $pdo = getIntegrationPdo();
    $status = in_array($data['status'] ?? 'active', ['active', 'paused', 'revoked']) ? ($data['status'] ?? 'active') : 'active';
    
    $stmt = $pdo->prepare('UPDATE integration_clients SET client_name = :client_name, contact_email = :contact_email, status = :status, monthly_quota = :monthly_quota, cost_per_image = :cost_per_image, notes = :notes WHERE id = :id');
    return $stmt->execute([
        ':client_name' => $data['client_name'],
        ':contact_email' => $data['contact_email'] ?? null,
        ':status' => $status,
        ':monthly_quota' => $data['monthly_quota'],
        ':cost_per_image' => $data['cost_per_image'],
        ':notes' => $data['notes'] ?? null,
        ':id' => $id
    ]);
}

function regenerateIntegrationClientToken(int $id, int $length = 48): ?string
{
    $pdo = getIntegrationPdo();
    $now = getSqlTimestampFunction();
    $token = generateIntegrationToken($length);
    $stmt = $pdo->prepare("UPDATE integration_clients SET api_token = :token, updated_at = $now WHERE id = :id");
    return $stmt->execute([':token' => $token, ':id' => $id]) ? $token : null;
}

function fetchIntegrationStats(): array
{
    $pdo = getIntegrationPdo();
    $stats = [
        'total_clients' => 0, 'active_clients' => 0, 'paused_clients' => 0,
        'total_conversions' => 0, 'total_cost' => 0.0, 'total_source_mb' => 0.0, 'total_converted_mb' => 0.0
    ];

    $clientsStmt = $pdo->query("SELECT COUNT(*) AS total, SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) AS active, SUM(CASE WHEN status != 'active' THEN 1 ELSE 0 END) AS inactive FROM integration_clients");
    if ($row = $clientsStmt->fetch(PDO::FETCH_ASSOC)) {
        $stats['total_clients'] = (int)$row['total'];
        $stats['active_clients'] = (int)$row['active'];
        $stats['paused_clients'] = (int)$row['inactive'];
    }

    $metricsStmt = $pdo->query('SELECT SUM(images_processed) AS conversions, SUM(total_cost) AS cost, SUM(total_source_bytes) AS source_bytes, SUM(total_converted_bytes) AS converted_bytes FROM conversion_metrics');
    if ($row = $metricsStmt->fetch(PDO::FETCH_ASSOC)) {
        $stats['total_conversions'] = (int)($row['conversions'] ?? 0);
        $stats['total_cost'] = (float)($row['cost'] ?? 0);
        $stats['total_source_mb'] = round(((int)($row['source_bytes'] ?? 0)) / 1048576, 2);
        $stats['total_converted_mb'] = round(((int)($row['converted_bytes'] ?? 0)) / 1048576, 2);
    }
    return $stats;
}

function fetchIntegrationClientsWithMetrics(): array
{
    $pdo = getIntegrationPdo();
    $stmt = $pdo->query('SELECT c.*, COALESCE(m.images_processed, 0) AS images_processed, COALESCE(m.total_cost, 0) AS total_cost, COALESCE(m.total_source_bytes, 0) AS total_source_bytes, COALESCE(m.total_converted_bytes, 0) AS total_converted_bytes FROM integration_clients c LEFT JOIN (SELECT client_id, SUM(images_processed) AS images_processed, SUM(total_cost) AS total_cost, SUM(total_source_bytes) AS total_source_bytes, SUM(total_converted_bytes) AS total_converted_bytes FROM conversion_metrics GROUP BY client_id) m ON m.client_id = c.id ORDER BY c.created_at DESC');
    
    $clients = [];
    while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
        $row['images_processed'] = (int)($row['images_processed'] ?? 0);
        $row['total_cost'] = (float)($row['total_cost'] ?? 0);
        $row['total_source_mb'] = round(((int)($row['total_source_bytes'] ?? 0)) / 1048576, 2);
        $row['total_converted_mb'] = round(((int)($row['total_converted_bytes'] ?? 0)) / 1048576, 2);
        $clients[] = $row;
    }
    return $clients;
}

function fetchRecentIntegrationEvents(int $limit = 10): array
{
    $pdo = getIntegrationPdo();
    $stmt = $pdo->prepare('SELECT e.*, c.client_name FROM conversion_events e LEFT JOIN integration_clients c ON c.id = e.client_id ORDER BY e.created_at DESC LIMIT :limit');
    $stmt->bindValue(':limit', $limit, PDO::PARAM_INT);
    $stmt->execute();
    return $stmt->fetchAll(PDO::FETCH_ASSOC);
}

function fetchIntegrationEventsPaginated(int $page = 1, int $perPage = 20): array
{
    $pdo = getIntegrationPdo();
    $page = max(1, $page);
    $offset = ($page - 1) * $perPage;

    $total = (int)$pdo->query('SELECT COUNT(*) FROM conversion_events')->fetchColumn();
    $pages = ceil($total / $perPage);

    $stmt = $pdo->prepare('SELECT e.*, c.client_name FROM conversion_events e LEFT JOIN integration_clients c ON c.id = e.client_id ORDER BY e.created_at DESC LIMIT :limit OFFSET :offset');
    $stmt->bindValue(':limit', $perPage, PDO::PARAM_INT);
    $stmt->bindValue(':offset', $offset, PDO::PARAM_INT);
    $stmt->execute();

    return [
        'events' => $stmt->fetchAll(PDO::FETCH_ASSOC),
        'total' => $total,
        'pages' => $pages,
        'current_page' => $page
    ];
}

function updateIntegrationConversionUrl(int $clientId, string $webpFilename, string $webpUrl): bool
{
    $pdo = getIntegrationPdo();
    try {
        // Subquery might be slow on large datasets, but acceptable for now
        $stmt = $pdo->prepare('UPDATE conversion_events SET webp_url = :url WHERE id = (SELECT id FROM conversion_events WHERE client_id = :client_id AND webp_filename = :filename ORDER BY created_at DESC LIMIT 1)');
        $stmt->execute([':url' => $webpUrl, ':client_id' => $clientId, ':filename' => $webpFilename]);
        return $stmt->rowCount() > 0;
    } catch (PDOException $e) {
        logIntegrationEvent('ERROR', 'Update URL failed', ['error' => $e->getMessage()]);
        return false;
    }
}

function logConversion(int $clientId, string $filename, int $originalSize, int $webpSize, float $cost, string $status = 'success'): void
{
    $pdo = getIntegrationPdo();
    $now = getSqlTimestampFunction();
    $savingsBytes = $originalSize - $webpSize;
    $savingsPercent = $originalSize > 0 ? ($savingsBytes / $originalSize) * 100 : 0;

    $stmt = $pdo->prepare("INSERT INTO conversion_logs (client_id, filename, original_size, webp_size, savings_bytes, savings_percent, cost, status, created_at) VALUES (:client_id, :filename, :original_size, :webp_size, :savings_bytes, :savings_percent, :cost, :status, $now)");
    $stmt->execute([
        ':client_id' => $clientId,
        ':filename' => $filename,
        ':original_size' => $originalSize,
        ':webp_size' => $webpSize,
        ':savings_bytes' => $savingsBytes,
        ':savings_percent' => $savingsPercent,
        ':cost' => $cost,
        ':status' => $status
    ]);
}

Fatal error: Uncaught Error: Call to undefined function initializeIntegrationDatabase() in /var/www/html/config.php:156
Stack trace:
#0 /var/www/html/test-db.php(2): require_once()
#1 {main}
  thrown in /var/www/html/config.php on line 156
